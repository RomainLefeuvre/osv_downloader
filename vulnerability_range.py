from typing import Dict, List, Set
import os
import pathlib
import json
from enum import Enum
import click
from osv_client.models.osv_event import OsvEvent
from osv_client.models.osv_vulnerability import OsvVulnerability
from osv_client.types import UNSET
from osv_client.models.osv_severity_type import OsvSeverityType
'''
Reads the vulnerabilities from the ```source folder``` and returns a dictionary of {ecosystem : List[OsvVulnerability]}
'''
def readVulnerabilities(source_folder) -> Dict[str,List[OsvVulnerability]]:
    print(f"-------Reading vulnerabilities from {source_folder}-------")
    vulnerabilities : Dict[str,List[OsvVulnerability]] = {}
    missing_vuln=0
    for root, dirs, files in os.walk(source_folder):
        
        categorie = pathlib.Path(root).name
        if root != source_folder :
            vulnerabilities[categorie]=[]
            for name in files:
                with open(os.path.join(root, name), 'r') as file:
                    data=file.read()
                obj = json.loads(data)
                try:
                    vulnerability = OsvVulnerability.from_dict(obj)
                    if not (hasattr(vulnerability,"withdrawn") and vulnerability.withdrawn != UNSET):
                        vulnerabilities[categorie].append(vulnerability)

                except Exception as error:
                    print(f"Error for {name} : {error}" )
                    missing_vuln+=1

    print(f"Number of missing vulnerabilities : {missing_vuln}")
    return vulnerabilities

class EventType(str, Enum):
    FIXED = 'FIXED'
    LAST_AFFECTED = 'LAST_AFFECTED'
    INTRODUCED = 'INTRODUCED'
    LIMIT = 'LIMIT'

'''
VulnerabilityRange internal representation
Performs extra check such as it :
- Ensures that there is at least an introduced event
- Ensures that there is no inconsistent duplication of event (two event pointing two the same commit but with a different type)
'''
class VulnerabilityRange :
     events : Dict[str,EventType]
     vulnerability_id: str
     repo_url: str
     severity: str
     def __init__(self,vulnerability_id : str, raw_events :List[OsvEvent], repo_url : str, severity:str):
          self.repo_url=repo_url
          self.events={}
          self.severity=severity
          self.vulnerability_id = vulnerability_id
          has_introduced=False
          if repo_url is UNSET  or repo_url is None or repo_url == "": 
              raise Exception("no repo_url")
          for event in raw_events :
             if event.fixed is not UNSET :
                  if event.fixed not in self.events :
                    self.events[event.fixed]=EventType.FIXED
                  else :
                    raise Exception("inconsitant duplication of event for "+vulnerability_id)

             elif event.last_affected is not UNSET :
                  if event.last_affected not in self.events:             
                    self.events[event.last_affected]=EventType.LAST_AFFECTED
                  else :
                    raise Exception("inconsitant duplication of event for "+vulnerability_id)

             elif event.limit is not UNSET :
                  if event.limit not in self.events :
                    self.events[event.limit]=EventType.LIMIT
                  else :
                    raise Exception("inconsitant duplication of event for "+vulnerability_id)
             elif event.introduced is not UNSET:
               if event.introduced not in self.events :
                  self.events[event.introduced]=EventType.INTRODUCED
                  has_introduced=True
               else :
                  raise Exception("inconsitant duplication of event for "+vulnerability_id)
          if not has_introduced:
               raise Exception("No introduced")
          
'''
Compute the ```VulnerabilityRange``` list from the OsvVulnerability objects
'''       
def getVulnerabilityRanges(vulnerabilities :Dict[str,List[OsvVulnerability]])->List[VulnerabilityRange]:
     print(f"-------Extracting vulnerability ranges-------")
     vulnerability_ranges = [] 
     missing_range_severity=0 
     missing_range_other_reason=0         
     for current_vulnerabilities in vulnerabilities.values() :
          for current_vulnerability in current_vulnerabilities:
               for affected in current_vulnerability.affected:
                    for range in affected.ranges:
                        if range.type == "GIT":
                             try :
                              repo_url= range.repo
                              severity_score :str
                              if (current_vulnerability.severity is UNSET) or  len(current_vulnerability.severity) == 0:
                                   missing_range_severity+=1
                                   severity_score = ""
                              elif  len(current_vulnerability.severity)>1:
                                  raise Exception("Multiple severity, update model")
                              else :
                                   severity = current_vulnerability.severity[0]
                                   if severity.type is not OsvSeverityType.CVSS_V3:
                                        raise Exception("Not CVSS_V3")
                                   else:
                                       severity_score=  severity.score  
                              vulnerability_ranges.append(VulnerabilityRange(current_vulnerability.id,range.events,repo_url,severity_score))
                             except Exception as e:
                                 print(f"skipping range {str(e)} {current_vulnerability.id}")
                                 missing_range_other_reason+=1 
     print(f"Number of range with no severity {missing_range_severity}")
     print(f"Number of range skiped due other reason (cf log) {missing_range_other_reason}")
     print(f"Number of range found : {len(vulnerability_ranges)}")
     return vulnerability_ranges

@click.command()
@click.option('--folder', default="./out", help='Workspace folder')
def main(folder:str):
   unzip_path=folder+"/unzip"
   out_path=folder+"/vuln_ranges.json"
   vulnerabilities = readVulnerabilities(unzip_path)
   vuln_ranges = getVulnerabilityRanges(vulnerabilities)
   json_object = json.dumps([vuln_range.__dict__ for vuln_range in vuln_ranges])
   with open(out_path, "w") as outfile:
        outfile.write(json_object)

if __name__ == '__main__':
    main()